#!/bin/sh
# \author Zachary Wartell, ... 

# [WORK IN PROGRESS]

# \brief Helper script to process and grade this Git Tutorial

# Usage: 
#
#    git-tutorial-check student_userid
#
# Output:
#
# For student with userid student_userid
#    - create directory call 'student_userid'
#    - clone repo
#    - create more subdirectories
#    - tar unzip file
#    - list first 2 levels of all files and directories in unzip .tar file directory
#    - run git log in subdirectories 
#    - all the above output appears on the command line and is also written to a file, log.txt, in the created subdirectory
#
# \todo add more semi-automatic grading/checking
# \todo make script more robust to student submissions that don't conform to expectations
# \todo make a variant for the git-micro-tutorial

#
# \todo make these into command line options for situations where we have to re-run script due to 
# weird/non-conformant student submissions, etc., but don't want to redo the clone, tar, etc. for that student.
#
#
# IDEAS
#    git log | grep commit | wc -l
# 

clone=1
#clone=0
dotar=1
#dotar=0

mkdir $1 2> /dev/null

pushd $1 > /dev/null

# redirect all command stdout and stderr output to log.txt and but also trace the file to display it on the console
rm -f log.txt
tail -f log.txt &
exec > log.txt 2>&1


echo
echo ---- CLONE 
echo
if [ $clone -eq 1 ]
then
	git clone https://cci-git.uncc.edu/$1/git-full-tutorial.git git-full-tutorial
else
	echo skipping clone
fi

pushd git-full-tutorial > /dev/null

echo
echo ---- TAR
echo

# allow for some student use of wrong name
FILE=`ls git-tutorial*.tar.gz`

if [ $dotar -eq 1 ]
then
	echo "tar --total --checkpoint=100 --checkpoint-action=dot -axf $FILE"
	tar --total --checkpoint=100 --checkpoint-action=dot -axf $FILE 
else
	echo skipping tar 
fi

DIR=${FILE%.tar.gz}  # extract directory name removing the .tar.gz
pushd $DIR > /dev/null

echo ---- DIRECTORY
pwd

echo
echo ---- FILE LIST 
echo
# list important "top level" files and directories
find . -maxdepth 2 ! \( -path "*.git*" \)

#\todo auto grading ideas: 
#    - check the expected files in the above list
#    - maybe use diff of a file containing the expect file list with the found file list and allow for a certain
#      range of differences.

echo
echo ---- DELETING non-detailed grading stuff
echo
# ProGit book has students clone some huge repo's from github, we don't need to grade the contents in details
# So after generating the file list (above), delete this big repo's in order to save us disk space.
rm -rf libgit2/* &     
rm -rf mylibgit/* &
# Note, the above run as background processes to allow rest of script run because the deletes can take while..
# If this script crashes, you need to decide whether to leave them running or to kill their pid, so
# also print their pid's.
ps -el | grep rm

#rm -rf libgit2/* & 
#rm -rf mylibgit/* &
#pgrep -a rm

echo
echo ---- GIT LOGS
echo

#\todo ZJW: Have I forgotten any repo's below ?

#\todo auto grading ideas
#   -[EASY]   just to line count on the commits and check for a expect number of lines
#   -[MEDIUM] use a regex to test whether commit message roughly match the instructions images

echo
echo ----
if [ -d "./simplegit-progit" ] 
then
	pushd simplegit-progit > /dev/null
	pwd
	git log
	popd > /dev/null
fi

echo
echo ----
if [ -d "./HelloWorld" ] 
then
	pushd HelloWorld > /dev/null
	pwd
	git log
	popd > /dev/null
fi

echo
echo ----
if [ -d "./Chapter_2_2" ] 
then
	pushd Chapter_2_2 > /dev/null
	pwd
	git log
	popd > /dev/null
fi


popd > /dev/null


popd > /dev/null

echo 
echo ---- DONE

# stop redirect to log.txt
# exec >&1 2>&1
# remove tar checkpoints from log
# sed -i "/tar: Read checkpoint [0-9]*/d" log.txt 

popd > /dev/null
